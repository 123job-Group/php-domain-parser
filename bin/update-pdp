#!/usr/bin/env php
<?php

/**
 * PHP Domain Parser: Public Suffix List based URL parsing.
 *
 * @see http://github.com/jeremykendall/php-domain-parser for the canonical source repository
 *
 * @copyright Copyright (c) 2017 Jeremy Kendall (http://jeremykendall.net)
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

use GuzzleHttp\Client;
use GuzzleHttp\Psr7\Request;
use Pdp\Storage\PublicSuffixListCachePsr16Adapter;
use Pdp\Storage\PublicSuffixListRemoteStorage;
use Pdp\Storage\PublicSuffixListStorage;
use Pdp\Storage\RootZoneDatabaseCachePsr16Adapter;
use Pdp\Storage\RootZoneDatabaseRemoteStorage;
use Pdp\Storage\RootZoneDatabaseStorage;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Log\AbstractLogger;
use Psr\Log\LogLevel;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;
use Symfony\Component\Cache\Psr16Cache;

const KEY_CACHE_DIR = 'cache-dir';

function success(string $message): void
{
    fwrite(STDOUT, $message.PHP_EOL);
}

function fail(string $message): void
{
    fwrite(STDERR, $message.PHP_EOL);
}

function get_vendor_path(): ?string
{
    for ($i = 1; $i <= 5; $i++) {
        $vendor = dirname(__DIR__, $i).'/vendor';
        if (is_dir($vendor) && file_exists($vendor.'/autoload.php')) {
            return $vendor;
        }
    }

    return null;
}

$vendor = get_vendor_path();
if (null === $vendor) {
    $message = <<<TEXT
        You must set up the project dependencies using composer
        see https://getcomposer.org
        TEXT;
    fail($message);
    die(1);
}

require $vendor.'/autoload.php';

$default_cache_dir = dirname(__DIR__).'/data';

$requestFactory = new class implements RequestFactoryInterface {
    public function createRequest(string $method, $uri): RequestInterface
    {
        return new Request($method, $uri);
    }
};

$logger = new class extends AbstractLogger {
    public function log($level, $message, array $context = [])
    {
        static $errorLevels = [
            LogLevel::EMERGENCY => 1,
            LogLevel::ALERT => 1,
            LogLevel::CRITICAL => 1,
            LogLevel::ERROR => 1,
            LogLevel::WARNING => 1,
            LogLevel::NOTICE => 1,
        ];

        $replace = [];
        foreach ($context as $key => $val) {
            $replace['{'.$key.'}'] = $val;
        }

        fwrite(
            isset($errorLevels[$level]) ? STDERR : STDOUT,
            strtr($message, $replace).PHP_EOL
        );
    }
};

/**
 * CLI colors
 */
$cyan = chr(27)."[36m";
$green = chr(27)."[32m";
$reset = chr(27)."[0m";
$redbg = chr(27)."[41m";
$yellow = chr(27)."[33m";

$arguments = getopt('h::', [
    'h',
    'help',
    KEY_CACHE_DIR.':',
]);

if (isset($arguments['help']) || isset($arguments['h'])) {
    $script = basename(__FILE__);
    $helpText = <<<HELP
{$yellow}Usage:$reset
    $script [options]

{$yellow}Options:$reset
$green    --%s=PATH$reset set the cache root directory ({$yellow}default:$reset '$default_cache_dir')
$green    -h, --help$reset       show the following help message

{$yellow}Help:$reset
   The {$green}update-php$reset command updates your PDP local cache.

{$yellow}Examples:$reset
   Refresh all the cache using another cache directory
   $green$script --cache-dir=/temp$reset

   Read more at https://github.com/jeremykendall/php-domain-parser/
HELP;

    success(sprintf(
        $helpText,
        KEY_CACHE_DIR
    ));

    die(0);
}

$context = filter_var_array($arguments + [KEY_CACHE_DIR => $default_cache_dir], [
    KEY_CACHE_DIR => ['filter' => FILTER_SANITIZE_STRING, 'flags' => FILTER_FLAG_STRIP_LOW],
]);

$ttl = new DateInterval('P1D');
$httpClient = new Client();

try {
    $cache = new Psr16Cache(new FilesystemAdapter('pdp', 3600, $context[KEY_CACHE_DIR]));
} catch (Throwable $exception) {
    if (null !== $logger) {
        $logger->error('Local cache initialisation failed with {exception}', ['exception' => $exception->getMessage()]);
    }
    fail("$redbg The script failed on initialisation.$reset");

    die(1);
}

success("$yellow Starting updating your local cache.$reset");
$error = 0;

try {
    $client = new PublicSuffixListRemoteStorage($httpClient, $requestFactory);
    $storage = new PublicSuffixListCachePsr16Adapter($cache, $ttl, $logger);

    $publicSuffixList = $client->getByUri(PublicSuffixListStorage::PSL_URL);

    if (!$storage->storeByUri(PublicSuffixListStorage::PSL_URL, $publicSuffixList)) {
        throw new RuntimeException('Could not save the Public Suffix List to the `'.$context[KEY_CACHE_DIR].'` cache.');
    }
} catch (Throwable $exception) {
    $logger->error('Local cache update failed with {exception}', ['exception' => $exception->getMessage()]);
    fail("$redbg The command failed to update the public suffix list local cache. $reset");
    ++$error;
}

try {
    $client = new RootZoneDatabaseRemoteStorage($httpClient, $requestFactory);
    $storage = new RootZoneDatabaseCachePsr16Adapter($cache, $ttl, $logger);

    $rootZoneDatabase = $client->getByUri(RootZoneDatabaseStorage::RZD_URL);

    if (!$storage->storeByUri(RootZoneDatabaseStorage::RZD_URL, $rootZoneDatabase)) {
        throw new RuntimeException('Could not save the Root Zone Database to the `'.$context[KEY_CACHE_DIR].'` cache.');
    }
} catch (Throwable $exception) {
    $logger->error('Local cache update failed with {exception}', ['exception' => $exception->getMessage()]);
    fail("$redbg The command failed to update the root zone database local cache. $reset");
    ++$error;
}

if (0 === $error) {
    success("$green Pdp local cache successfully updated. $reset");

    die(0);
}

fail("$redbg The command failed to update the root zone database local cache. $reset");
die(1);
